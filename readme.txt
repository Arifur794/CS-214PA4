Systems Programming PA4 - Indexer
Arifur Rahman
Design analysis: For this assignment I used a prefixtree to in order to store data from the files.  If there is a prefix node whose isWord comes out as true, my program will sotre a linked list that contains the file names and also the number of times each word or token shows up.  I also have a struct that has the root of the prefix tree which can get access to the rest of the entire tree.  Every new node will be added to the end of the linked list. It is sorted after going through all the files.  Pathnames are used insted of just the files names in order. This makes it clear as to which file to choose from if there happens to be more than one with the same name but in different directories.  I have a check if there already exists a file or directory with the same name as the indexer file. User can choose to overwrite or not.   When directories are overwritten, the directory and all its files and sub-directories are deleted.  Another check is used to see if the given file or directory in the second argument exists. If not, an error will appear and the program will end.  After the inverted index is created, all the files and directories are closed and all the previously allocated data structures are freed.  
Space Analysis:  For this assignment, I allocated memory for each of the nodes in the prefixtree and the array of 36 for each prefix node that we allocate memory for.  Memory for each linked list node is allocated within the prefix nodes that are at the end of each word.  There is also memory allocated for a struct that holds the root of the prefix tree.  There are two charactrer arrays that are also allocated memory which will concatinante the inverted index output.  There is another character array with memory allocated in order to print the words/tokens from the prefix tree. All data structures that had memory allocated is then freed.  
Efficiency Analysis:     n= # of words       m= # of files
O(nm^2)
The worst case for this efficiency analysis happens when for every n words, we have to go to the end of the linked list (m)  and go back (m) when sorting if the updated word has a higher occurence than the rest of the linked list.      